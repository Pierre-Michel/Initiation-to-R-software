---
title: "Initiation to R software Session II"
author: "Pierre Michel"
date: "Master AMSE 1st year, 2019"
output:
  beamer_presentation: default
  ioslides_presentation:
    transition: slower
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Matrices

## Matrices: `matrix()`

Matrices are vectors that take one more argument: the **dimenson**: `dim()`.

The dimension is a vector of length 2 defining the number of **rows** and **columns** of the matrix.

Values in a matrix have the **same mode**.

```{r matrix, echo=T, eval=T, warning=F}
M = matrix(1:10, 2, 5)
M
```
## Matrices: `dim()`

Really ? Matrices are vectors ?

```{r matrix_dim, echo=T, eval=T, warning=F}
M = 1:10
dim(M) = c(2,5)
M
dim(M)
```

## Creating matrices: `matrix()`

`matrix(data, nrow, ncol, byrow, dimnames)`

- `data`: a vector,
- `nrow`: number of rows,
- `ncol`: number of columns,
- `byrow`: filling by row ?
- `dimnames`: list of two vectors, with names of rows and columns respectively.

## Creating matrices: `matrix()`

```{r matrix_fun, echo=T, eval=T, warning=F}
M=matrix(1:10, 2, 5)
N=matrix(1:10, 2, 5, byrow = T)
R=matrix(1:10, 2, 5, dimnames = list(1:2, letters[1:5]))
print(M); print(N); print(R)
```

## Creating matrices: `matrix()`

What if the length of the vector and the dimension of the matrix do not match ?

\footnotesize
```{r matrix_match, echo=T, eval=T, warning=T}
P=matrix(1:5, 2, 5); P;
Q=matrix(1:3, 2, 5);
```

## Selecting matrix elements

(De)select **one row/column** using **position indices** $(i,j)$.

```{r select_matrix, echo=T, eval=T, warning=T}
M = matrix(1:15, 3, 5)
M; M[1,]; M[3,]
```

## Selecting matrix elements

(De)select **several rows/columns** using **position indices** $(i,j)$.

```{r select_matrix_r, echo=T, eval=T, warning=T}
M; M[c(1,3),]; M[-c(2,4),]
```

## Selecting matrix elements

(De)select **sub-matrices** using **position indices** $(i,j)$.

```{r select_matrix_sub, echo=T, eval=T, warning=T}
M; M[1,2]; M[c(1,2),-3]
```

## Selecting matrix elements

(De)select **sub-matrices** using **logical matrices**.

```{r select_matrix_log, echo=T, eval=T, warning=T}
M; M[M[,1]>1,]
```

## Selecting matrix elements

(De)select **vectors** using **linear indices** (return a vector).

```{r select_matrix_lin, echo=T, eval=T, warning=T}
M[3]
v = 1:3; M[v]
M[-v]; M[M>7]
```

## Matrix operations

- Usual operators: `+`,`-`,`*`,`/`,`=`,`>`,`<`, ...
- Algebraic matrix product: `%*%`
- Matrix transposition: `t()`
- Diagonalization: `eigen()`
- Determinant: `det()`
- Determinant: `det()`
- Inverse matrix: `solve()`

```{r mat_vec, echo=T, eval=F, warning=T}
# Try this example
M=matrix(c(1,2,1,0),2,2)
v=c(1,0,2,1)
M
v
M+v
```

## Matrix operations: `+` and `*`

```{r mat_op, echo=T, eval=T, warning=T}
M = matrix(c(1,2,1,0),2,2); N = matrix(1:4,2,2)
M + 2
M * N
```

## Matrix operations: `%*%` and `t()`

```{r mat_op_tr, echo=T, eval=T, warning=T}
M %*% N
t(M)
```

## Matrix operations: useful functions

* `diag()` can take both vectors and matrices as input. If the input is a **vector**, it returns a **diagonal matrix** with the vector in diagonal. If the input is a **matrix**, it returns a vector which is the matrix diagonal.
* `sum()` computes the sum of all elements in a matrix, use `sum(, na.rm = T)` to avoid missing values.
* `rbind()` and `cbind()` concatenate vertically (resp. horizontally) two matrices.

```{r mat_useful, echo=T, eval=F, warning=T}
# Try this example
v=1:2; diag(v)
M=matrix(1:2,2,2); diag(M)
sum(M)
cbind(M,c(1,1)); rbind(M,c(1,1))
```

## Matrix operations: `apply()`

This function applies a function (or an operator) to the rows/columns of a matrix.

`apply(M, margin, fun, ...)`

- `M` is a matrix
- `margin` specifies rows (`margin = 1`) or columns (`margin = 2`)
- `fun` is the function to apply

```{r mat_apply, echo=T, eval=F, warning=T}
# Try this example
M=matrix(c(1,2,1,0),2,2)
apply(M, 1, sum) # sum of lines
apply(M, 2, sum) # sum of columns
```

# Lists 

## Lists

A list is an ordered collection of **objects** (vectors, matrices, factors, dataframes, lists). These objects do not need to have the same type, mode and length. 

```{r list, echo=T, eval=T, warning=T}
list(x = 1:5, y = letters[1:5], a = c(T, F))
```

## Creating lists

Lists can be **named**, or **unnamed**. 

```{r list_nam, echo=T, eval=T, warning=T}
L = list(x = 1:5, y = letters[1:8]); L # named list
L = list(1:5, letters[1:8]); L # unnamed list
```

## Selecting list elements

An object in a list can be accessed by **name** (using `$`) or by **index** (using `[[]]`), selection of **sublists** is also possible.

```{r list_sel, echo=T, eval=F, warning=T}
# try this example
L$x # select by name
is.vector(L$x) # is vector ?
L[[1]] # select by index
L[1] # a sublist
L[c(1,2)] # another sublist
```

# Dataframes

## Dataframes (`data.frame`)

- Inside R, dataframes are **lists**, for which fields represent **columns** of same length.
- Visually, dataframes are **matrix**, in which columns can have different modes (character, numeric, logical).

```{r df, echo=T, eval=T, warning=T}
L = LETTERS[1:3]
D = data.frame(x=rep(1,5), y=1:5, z=sample(L, 5, repl=T))
D
```

## Selecting `data.frame` elements

- One can select the rows/columns and elements using their **position indices** or **names**.
- An element from a `data.frame` is a **factor**

```{r df_el, echo=T, eval=F, warning=T}
# Try this example
L = LETTERS[1:3]
D = data.frame(x=rep(1,5), y=1:5, z=sample(L, 5, repl=T))
D[,3] 
D[”fac”]
D$fac
D[1,3]
D[1,"z"]
is.factor(D[,3])
```

## Useful functions for `data.frame` (and `matrix`)

- `names()`, `colnames()`: return the names of columns or create them.
- `rownames()`: returns the names of rows or create them.
- `dimnames()`: returns a 2-field list containing the names of rows/columns
- `dim()`: returns the dimension of the `data.frame` (or `matrix`).
- `rbind()`, `rbind()`: concatenate by rows/columns.
- `edit()`, `fix()`: opens an  editor to set the values of the `data.frame`. 

## Useful functions for `data.frame` (and `matrix`)

```{r df_fun, echo=T, eval=F, warning=T}
# Try this example
L = LETTERS[1:3]
D = data.frame(x=rep(1,5), y=1:5, z=sample(L, 5, repl=T))
colnames(D)
colnames(D)=c(LETTERS[1:2], "z")
D
rownames(D)=letters[1:5]
D
dimnames(D)
dim(D)
cbind(D, room = rep(c(1,2), length = 5))
```

## Reading `data.frame`
You can list objects of type `data.frame`:

- `data()`: list all objects of type `data.frame` available by default in the package `datasets`.
- `try(data(package = "cluster"))`: list all objects of type `data.frame` available in the package `cluster`.

You can also load them:

- `data(USArrests)`: load the `data.frame` *USArrests* (in package `datasets`).
- `help(USArrests)`: give information about `data.frame` *USArrests*

```{r df_read, echo=T, eval=F, warning=T}
# Try this example
library(cluster) 
data(agriculture) 
# or data(agriculture,package="cluster")
```

# Complements

## Modes

```{r modes, echo=F, eval=T, warning=F}
knitr::kable(data.frame(type = c("vector", "factor", "array", "matrix", "data.frame", "ts", "list"),
                        mode = c("numeric, character, logical","numeric, character","numeric, character, logical",
                                 "numeric, character, logical","numeric, character, logical","numeric, character, logical","numeric,character, logical"),
           multimode = c("no","no","no","no","yes","yes","yes")))
```

## Conversion / Identification

`as` for conversion, `is` for identification

- `as.vector`
- `is.vector()`
- `as.factor()`
- `is.factor()`
- `as.list()`
- `is.list()`
- `as.matrix()`
- `is.matrix()`
- `as.data.frame()`
- `is.data.frame()`

## Very useful functions...

\small
```{r useful_fun, echo=F, eval=T, warning=F}
knitr::kable(data.frame(function_name = c("sum(x)", "prod(x)", "max(x), min(x)", "which.max(x)", "which.min(x)", "range(x)", "mean(x)","median(x)"),
                        description = c("Sum of the elements of x", "Product of the elements of x", "Maximum, minimum of the elements of", "Returns the index of the maximum of the elements of x", "Returns the index of the minimum of the elements of x", "Similar to c(min(x), max(x))", "Mean of the elements of x", "Median of the elements of x")))
```

## Other very useful functions...

\small
```{r useful_fun2, echo=F, eval=T, warning=F}
knitr::kable(data.frame(function_name = c("var(x)", "cov(x)", "cor(x)", "sd(x)", "round(x,n)", "rev(x)", "sort(x)", "rank(x)", "scale(x)"),
                        description = c("Variance of the elements of x", "Covariance matrix if x is a matrix","Correlation matrix of x if x is a matrix or a data.frame", "Standard deviation of the elements of x", "Rounds the elements of x to n decimals", "Reverse the order of the elements of x", "Sort the elements of x in ascending order", "Rank the elements of x", "Scale (center and reduce) x")))
```

## ... and other very useful functions...

\small
```{r useful_fun3, echo=F, eval=T, warning=F}
knitr::kable(data.frame(function_name = c("pmin(x,y,...)","cumsum(x)","cumprod()", "cummin()", "cummax()","match(x,y)","choose(x,k)","na.omit()","na.fail()"),
                        description = c("A vector whose element i is the minimum of x[i] and y[i]",
                                        "A vector whose element i is the sum of x[i] and y[i]",
                                        "Similar as cumsum() with product",
                                        "Similar as cumsum() with minimum",
                                        "Similar as cumsum() with maximum",
                                        "Vector of same length as x with elements of x that are in y",
                                        "Binomial coefficient","Remove observations with missing values",
                                        "Returns an error message if x contains at least one NA")))
```

## ... and others

\small
```{r useful_fun4, echo=F, eval=T, warning=F}
knitr::kable(data.frame(function_name = c("unique()","table()","subset()", "sample(x,n)"),
                        description = c("Returns a similar object without duplicates",
                                        "Returns table of counts of the values of x",
                                        "Returns a selection of x based on criteria",
                                        "Random sampling of x of size n, without replacement")))
```


Do not hesitate to try all of these powerful functions !